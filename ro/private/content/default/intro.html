<h1>
    Идея
</h1> 

<p> 
Stateless сервер формирует декларативные директивы и передает их на клиент 
в ответ на запрос. Клиент применяет директивы к имеющемуся DOM, включая 
изменения DOM, управления событиями, действиям. В дальнейшем события 
повторно направляются на сервер, который формирует новые директивы.
</p>
     
<pre>
┌──────────┐                  ┌────────────┐                 ┌───────┐
│          │─── директивы ───▶│    Pusa    │──── контент ───▶│       │
│ Backend  │                  │ (Frontend) │                 │  DOM  │
│          │◀─── события ─────│            │◀─── события ────│       │
└──────────┘                  └────────────┘                 └───────┘
</pre>

<h2>
    Как работает
</h2>

<p>
    Frontend на основе директив Backend выбирает в фокус требуемые DOM 
элементы с которыми далее выполняет действия, включая изменение контента, 
создание удаление элементов, модификация стилей. Таким образом на Backend 
переносится управление, а фактическая работа остается на Front.
</p>

</p>
    При загрузке страницы браузер загружает DOM content, JS ядро 
    Pusa, и стартовые директивы.
</p>

<p>

    Frontend направляет события браузера (как то click, blur, focus, 
    keypress, mousemove), атрибуты и свойства событийного элемента, URL 
    текущей страницы на Backend.
</p>

<p>
    На основании полученных данных Pusa-Back определяет контроллер, 
    выполняет полезную нагрузку и формирует ответный набор команд.
</p>

<p>
    Получив ответ Pusa-Front выполняет команды, изменяя контент DOM 
    и производя визуальные эффекты.
</p>


<h2>
Назначение
</h2>

<p>
    Pusa предназначена для реализации многоуровневых веб интерфейсов со 
    значительным перечнем пользовательского и адимнистративного 
    функционала.
</p>


<h2>
Особенности
</h2>

<p>
Pusa переносит часть нагрузки с Frontend на Backend и увеличивает частоту 
обмена с сервером. Частота обращения компенсируется сокращением нагрузки от 
исполнения каждого запроса за счет внутренней архитектуры Pusa. Backend не 
выполняет "тяжелую" работу с DOM, а формирует исключительно инструкции для 
Frontend.
</p>

<p>
Pusa не использует JS код вне базового фреймворка, но требует включенного 
JS на стороне браузера для реализации функционала.
</p>

<p>
Интерактивные приложения, активно использующие оnmousemove формируют 
значительный поток событий. Pusa имеет механизмы буферизации вызовов и 
замыканий, позволяющие обрабатывать множественные события, например, 
mousemove без повышения нагрузки на сервер. Однако, при необходимости 
обработки каждого события с выполнением логики Pusa не является оптимальным 
решением. Пример: кастомный код JS потребуется при разработке ядра онлайн 
графических редакторов.
</p>

<p>
В случае, если прикладная задача требует использования сторонних JS 
скриптов, они должны быть загружены в браузер. Pusa предусматривает 
механизм использования внешних скриптов JS.
</p>



<h2>
    Преимущества
</h2>

<p>
Pusa минимизирует необходимость JS разработки для Frontend, а следовательно 
не требует согласования API вызовов между Backend и Frontend. Отсутствие 
кастомного JS разрешает проблему сериализации REST, исключая необходимость 
средств типа gRPC и тд. Компоненты ограничены Backend и не 
распространяются на Frontend.
</p>

<p>
Клиентское JS приложение в браузере компактно и стабильно. Pusa 
концептуально повышает безопасность, так как код приложения Backend не 
доступен извне.
</p>

<p>
Направление событий на сервер представляет для SEO весь объем действий 
пользователя для анализа.
</p>

<p>
Для пользователя минимизируется время загрузки стартовых страниц.
</p>

